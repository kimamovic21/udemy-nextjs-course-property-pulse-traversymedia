Udemy Nextjs Course Property Pulse Traversymedia


Section 1. Introduction

01. Welcome To The Course
02. PropertyPulse Project Demo
03. A Note On The Project Structure
04. What is Next.js ?
05. Environment Setup


Section 2. Next.js Fundamentals & Project Start

06. New Project & Folder Structure

07. Layout, Homepage & Metadata
-u folderu app kreiramo komponentu layout.jsx
-u komponenti layout.jsx kreiramo funkciju MainLayout()
-funkciji MainLayout() dodajemo parametar destruktuirani prop children
-kreiramo komponentu page.jsx
-kreiramo folder assets
-u folderu assets kreiramo folder styles i globals.css fajl
-u komponentu layout.jsx importujemo globals.css fajl
-kreiramo i eksportujemo varijablu const metadata

08. File-Based Routing
-kreiramo folder properties i komponentu page.jsx 
-u folderu properties kreiramo folder add i komponentu page.jsx
-u folderu properties kreiramo folder [id] i komponentu page.jsx
-u komponentu app/page.jsx importujemo komponentu Link

09. Server vs Client Components & Router Hooks
-u komponentu [id]/page.jsx importujemo i kreiramo funkciju useRouter iz paketa Next Navigation
-vrijednost funkcije useRouter() pohranjujemo u varijablu const router
-dodajemo direktivu 'use client'
-importujemo i kreiramo funkciju useParams()
-vrijednost funkcije useParams() pohranjujemo u destruktuiranu varijablu const { id }
-importujemo i kreiramo funkciju useSearchParams()
-vrijednost funkcije useSearchParams() pohranjujemo u varijablu const searchParams
-importujemo i kreiramo funkciju usePathname()
-vrijednost funkcije usePathname() pohranjujemo u varijablu const pathname

10. Start On The Navbar
-preuzmemo folder _theme_files
-kreiramo folder components i komponentu Navbar.jsx
-u komponentu layout.jsx importujemo komponentu Navbar.jsx
-u komponentu Navbar.jsx importujemo komponentu Images iz paketa Next Image
-importujemo slike logo i profileDefault

11. Navbar Links, Dropdowns & React Icons
-u komponentu Navbar.jsx importujemo komponentu Link
-preimenujemo HTML elemente <a> sa komponentom Link
-u terminalu instaliramo paket React Icons
-importujemo funkciju useState()
-kreiramo state varijablu isMobileMenuOpen i set funkciju setIsMobileMenuOpen
-u div elementu za Mobile menu button, button elementu dodajemo dogadaj onClick
-u dogadaj onClick proslijedujemo anonimnu funkciju
-u anonimnu funkciju proslijedujemo funkciju setIsMobileMenuOpen
-u jsx dodajemo uslov {isMobileMenuOpen && (...)} i div element za Mobile menu
-kreiramo state varijablu isProfileMenuOpen i set funkciju setIsProfileMenuOpen
-u div elementu za Profile dropdown button, button elementu dodajemo dogadaj onClick
-u dodajemo onClick proslijedujemo anonimnu funkciju
-u anonimnu funkciju proslijedujemo funkciju setIsProfileMenuOpen
-dodajemo uslov {isProfileMenuOpen && (...)}

12. Active Links & Conditional Rendering
-u komponentu Navbar.jsx importujemo i kreiramo funkciju usePathname
-vrijednost funkcije usePathname() pohranjujemo u varijablu const pathname
-u div elementu za Desktop Menu Hidden below md screens, komponenti Link dodajemo dinamicku klasu
-u dinamicku klasu dodajemo uslov ternarni operator pathname === '/'
-kreiramo state varijablu isLoggedIn i set funkciju setLoggedIn
-dodajemo nekoliko uslova {isLoggedIn && (...)}
-u div elementu za Right Side Menu dodajemo uslov {!isLoggedIn && (...)}

13. Homepage Components
-u folderu components kreiramo komponentu Hero.jsx
-kreiramo komponentu InfoBoxes.jsx
-u komponentu app/page.jsx importujemo komponente Hero.jsx i InfoBoxes.jsx
-kreiramo komponentu InfoBox.jsx
-u komponenti InfoBox.jsx funkciji InfoBox() dodajemo parametre destruktuirane props
-u komponentu InfoBoxes.jsx importujemo komponentu InfoBox
-kreiramo komponentu Footer.jsx
-u komponentu layout.jsx importujemo komponentu Footer.jsx

14. Properties Page
-kreiramo komponentu PropertyCard.jsx

15. Property Card Dynamic Data
-u komponenti PropertyCard.jsx, funkciji PropertyCard() dodajemo parametar destruktuirani prop property
-kreiramo funkciju getRateDisplay()
-importujemo React ikonice
-dinamicki prikazujemo podatke u jsx-u

16. Home Property Listings
-u folderu components kreiramo komponentu HomeProperties.jsx
-u komponentu app/page.jsx importujemo komponentu HomeProperties.jsx
-u komponenti HomeProperties.jsx u jsx dodajemo ternarni uslov recentProperties === 0 

17. Custom Not Found & Loading Pages
-u folderu app kreiramo komponentu not-found.jsx
-u folderu app kreiramo komponentu loading.jsx
-u terminalu instaliramo paket React Spinners
-u komponentu loading.jsx importujemo komponentu ClipLoader


Section 3: Database, API Routes & Property Components

18. Create MongoDB Database
-kreiramo fajlove .env.local i .env.local.example
-u env.local fajlu kreiramo varijable NEXT_PUBLIC_DOMAIN, NEXT_PUBLIC_API_DOMAIN i MONGODB_URI

19. MongoDB Compass & Importing Data
-u MongoDB bazi podataka kreiramo bazu sa imenom propertypulse
-u bazi propertypulse kreiramo kolekciju properties
-kreiramo properties-mongo.json fajl
-taj fajl importujemo u kolekciju properties

20. Database Connection & Mongoose
-kreiramo folder config
-u folderu config kreiramo database.js fajl
-u terminalu instaliramo pakete MongoDB i Mongoose
-u database.js fajl importujemo paket mongoose
-kreiramo varijablu let connected
-kreiramo asinhronu funkciju connectDB()
-u funkciju connectDB() dodajemo metodu mongoose.set()
-dodajemo uslov if (connected)
-dodajemo blokove koda try - catch
-u terminalu instaliramo paket Colors

21. Your First API Route
-u folderu app kreiramo folder api
-u folderu api kreiramo folder properties i route.js fajl
-u route.js fajlu kreiramo i eksportujemo asinhronu funkciju GET()
-u funkciju GET dodajemo blokove koda try - catch
-otvorimo link http://localhost:3000/api/properties
-importujemo funkciju connectDB
-u blok koda try dodajemo funkciju connectDB()

22. Property & User Models
-kreiramo folder models
-u folderu models kreiramo User.js fajl
-u User.js fajlu kreiramo funkciju new Schema({ ... })
-vrijednost funkcije new Schema() pohranjujemo u varijablu const UserSchema
-importujemo objekte iz paketa Mongoose
-kreiramo varijablu const User
-varijablu User eksportujemo kao default
-u folder models kreiramo Property.js fajl
-u Property.js fajlu kreiramo funkciju new Schema({ ... })
-vrijednost funkcije new Schema() pohranjujemo u varijablu const PropertySchema
-kreiramo varijablu const Property
-varijablu const Property eksportujemo kao default

23. Fetch Data Using Server Component
-u properties/route.js fajl importujemo model Property
-dodajemo metodu await Property.find({ });
-vrijednost metode Property.find() pohranjujemo u varijablu const properties
-u komponenti properties/page.jsx kreiramo asinhronu funkciju  fetchProperties()
-u funkciju fetchProperties() dodajemo blokove koda try - catch
-u bloku koda try kreiramo varijablu const res
-dodajemo uslov if (!res.ok)
-dodajemo return res.json()
-varijabli properties dodajemo metodu sort()
-u komponenti HomeProperties.jsx kreiramo funkciju fetchProperties() 
-kreiramo varijablu const properties

24. Requests File
-kreiramo folder utils i requests.js fajl
-u requests.js fajlu kreiramo i eksportujemo asinhronu funkciju fetchProperties()
-u komponentu HomeProperties.jsx importujemo funkciju fetchProperties()
-u komponentu properties/page.js importujemo funkciju fetchProperties()
-u requests.js fajlu kreiramo varijablu const apiDomain
-u funkciju fetchProperties() dodajemo uslov if (!apiDomain)

25. Fetch Single Property
-u folderu properties kreiramo folder [id]
-u folderu [id] kreiramo route.js fajl
-u [id]/route.js fajlu kreiramo i eksportujemo asinhronu funkciju GET()
-funkciji GET dodajemo parametre request i { params }
-u komponentu [id]/page.jsx dodajemo direktivu 'use client'
-importujemo funkcije useState i useEffect
-importujemo funkciju useParams iz paketa Next Navigation
-u requests.js fajlu kreiramo i eksportujemo asinhronu funkciju fetchProperty(id)
-u komponentu [id]/page.jsx importujemo funkciju fetchProperty
-iz funkciji useParams() destruktuiramo varijablu const { id }
-kreiramo state varijable property i loading
-kreiramo set funkcije setProperty i setLoading
-kreiramo funkciju useEffect()
-u funkciji useEffect() kreiramo anonimnu funkciju fetchPropertyData
-u funkciju fetchPropertyData dodajemo uslov if (!id) return
-dodajemo blokove koda try - catch - finally
-u bloku koda try kreiramo varijablu const property
-dodajemo funkciju setProperty(property)
-u blok koda finally dodajemo funkciju setLoading(false)
-u funkciju useEffect() dodajemo uslov if (property === null)
-u uslov if dodajemo funkciju fetchPropertyData()

26. Single Property Page
-u folderu components kreiramo komponentu PropertyHeaderImage.jsx
-u komponentu [id]/page.jsx importujemo komponentu PropertyHeaderImage.jsx
-dodajemo uslov if (!property && !loading)
-u return izjavu dodajemo komponentu PropertyHeaderImage
-komponenti PropertyHeaderImage dodajemo prop image
-u komponenti PropertyHeaderImage.jsx, funkciji PropertyHeaderImage() dodajemo parametar destruktuirani prop image
-importujemo komponente Image iz paketa Next Image
-u tailwind.config.js fajlu dodajemo konfiguracione objekte fontFamily i gridTemplateColumns

27. Property Details Component
-u folderu components kreiramo komponentu PropertyDetails.jsx
-iz komponente [id]/page.jsx kopiramo main HTML element i sadrzaj unutar njega u komponentu PropertyDetails.jsx
-u return izjavi komponenti PropertyDetails dodajemo prop property
-u komponenti PropertyDetails.jsx funkciji PropertyDetails() dodajemo parametar destruktuirani prop property
-u return izjavi dodajemo nekoliko ternarnih uslova property?.rates ? (...) : (...)
-dinamicki prikazujemo vrijednost varijabli
-dodajemo metodu property?.amenities?.map()

28. Spinner Component
-u folderu components kreiramo komponentu Spinner.jsx
-u komponentu [id]/page.jsx importujemo komponentu Spinner.jsx


Section 4: Next Auth, Sessions & Google Providers

29. Google OAuth Setup
-otvorimo link https://console.cloud.google.com/
-kreiramo novi projekt 
-u .env.local fajlu kreiramo varijable GOOGLE_CLIENT_ID i GOOGLE_CLIENT_SECRET

30. Next Auth & Provider Setup
-otvorimo link https://next-auth.js.org/
-u terminalu instaliramo paket Next Auth sa komandom npm i next-auth
-u folderu app/api kreiramo folder auth
-u folderu auth kreiramo folder [...nextauth]
-u folderu [...nextauth] kreiramo route.js fajl
-u folderu utils kreiramo authOptions.js fajl
-u authOptions.js fajlu kreiramo i eksportujemo konfiguracioni objekt authOptions
-u konfiguracionom objektu authOptions kreiramo konfiguracione niz providers i konfiguracioni objekt callbacks
-u objektu callbacks kreiramo asinhrone funkcije signIn() i session()
-u app/api/auth/[...nextauth] folderu u route.js fajl importujemo objekt authOptions i funkciju NextAuth
-kreiramo funkciju NextAuth(authOptions)
-vrijednost funkcije NextAuth() pohranjujemo u varijablu const handler
-eksportujemo funkciju handler kao GET i POST

31. Session Provider Wrapper
-u folderu components kreiramo komponentu AuthProvider.jsx
-u komponentu AuthProvider.jsx importujemo komponentu SessionProvider iz paketa Next Auth
-funkciji AuthProvider() dodajemo parametar destruktuirani prop children
-u komponentu layout.jsx importujemo komponentu AuthProvider.jsx
-kreiramo nove varijable NEXT_AUTH_URL, NEXT_AUTH_URL_INTERNAL, NEXT_AUTH_URL_SECRET u .env fajlu
-u terminal ukucamo komandu openssl rand -base64 32 da generisemo Next Auth Secret
-u komponentu AuthProvider.jsx dodajemo direktivu 'use client'

32. Sign In Button
-u komponentu Navbar.jsx importujemo funkcije  signIn, signOut, useSession, getProviders 
-kreiramo funkciju useSession()
-iz funkcije useSession() destruktuiramo varijablu const { data: session }
-u komponenti Navbar.jsx u return izjavi umjesto uslova isLoggedIn && (...) dodajemo session && (...)
-preimenujemo varijablu isLoggedIn u providers, a set funkciju setIsLoggedIn u setProviders
-importujemo i kreiramo funkciju useEffect()
-u funkciji useEffect() kreiramo asinhronu funkciju setAuthProviders
-u funkciji setAuthProviders() kreiramo varijablu const res
-dodajemo set funkciju setProviders u koju proslijedujemo vrijednost varijable res
-pozivamo funkciju setAuthProviders()
-u return izjavi dodajemo metodu {providers && Object?.values(providers)?.map()}
-u metodu map dodajemo button element
-button elementu dodajemo dogadaj onClick
-u dogadaj onClick proslijedujemo anonimnu funkciju
-u anonimnu funkciju proslijedujemo funkciju signIn()
-dodajemo metodu {!session && providers && Object?.values(providers)?.map()} za mobile menu 

33. Save User to Databse & Session
-u authOptions.js fajl importujemo funkciju connectDB() i model User
-u funkciju signIn() dodajemo funkciju await connectDB()
-kreiramo varijablu const userExists
-dodajemo uslov if (!userExists)
-u uslovu if (!userExists) kreiramo varijablu const username 
-dodajemo metodu await User.create({ ... })
-dodajemo return true
-u funkciji session() kreiramo varijablu const user
-dodajemo metodu session?.user?.id = User?._id.toString()
-dodajemo return session

34. Profile Image
-u komponenti Navbar.jsx kreiramo varijablu const profileImage
-u komponentu Image za korisnika proslijedujemo u prop src vrijednost varijable profileImage
-u next.config.js fajl dodajemo objekt konfiguracioni objekt images

35. Sign Out & Protect Routes
-u komponenti Navbar.jsx, button elementu Sign Out dodajemo dogadaj onClick
-u dogadaj onClick proslijedujemo anonimnu funkciju
-u anonimnu funkciju proslijedujemo funkciju signOut()
-kreiramo middleware.js fajl
-u middleware.js fajlu eksportujemo funkciju default
-kreiramo i eksportujemo konfiguracioni objekt varijablu const config
-u komponenti Navbar.jsx komponentama Link Your Profile i Saved Properties dodajemo dogadaj onClick
-u dogadaj onClick proslijedujemo anonimnu funkciju
-u anonimnu funkciju proslijedujemo funkciju setIsProfileMenuOpen(false) da se menu ukloni kada kliknemo na profil i sacuvane nekretnine


Section 5: Create Properties & Cloudinary Integration

36. Add Property Form & Component State
-kreiramo komponentu PropertyAddForm.jsx
-komponenti PropertyAddForm.jsx dodajemo direktivu 'use client'
-kopiramo form element i ostale HTML elemente iz foldera _theme_files
-u komponentu properties/add/page.jsx importujemo komponentu PropertyAddForm.jsx
-u komponenti PropertyAddForm.jsx kreiramo state varijablu mounted i set funkciju setMounded()
-kreiramo funkciju useEffect()
-kreiramo state varijablu fields i set funkciju setFields()
-kreiramo tri funkcije handleChange(), handleAmenitiesChange() i  handleImageChange()
-select elementu dodajemo prop value i dogadaj onChange
-input elementima dodajemo prop value i dogadaj onChange

37. Form Input Handlers
-u komponenti PropertyAddForm.jsx, funkciji handleChange() dodajemo parametar e
-u funkciji handleChange() destruktuiramo varijable const { name, value } iz metode e.target
-dodajemo uslov if(name.includes('.'))
-u uslov if destruktuiramo varijable const [outerKey, innerKey] iz metode name.split()
-dodajemo set funkciju setFields()
-u funkciju setFields() proslijedujemo anonimnu funkciju sa parametrom prevFields
-dodajemo uslov else
-u uslov else dodajemo funkciju setFields()
-funkciji handleAmenitiesChange() dodajemo parametar e
-u funkciji handleAmenitiesChange() destruktuiramo varijable const { value, checked } iz metode e.target
-kreiramo varijablu const updatedAmenities
-dodajemo uslov if (checked) i else
-u if (checked) dodajemo metodu updatedAmenities.push(value)
-u uslovu else kreiramo varijablu const index 
-dodajemo uslov if (index !== -1)
-u uslov if (index !== -1) dodajemo metodu updatedAmenities.splice(index, 1)
-izvan if - else uslova dodajemo funkciju setFields()
-u funkciju setFields() proslijedujemo anonimnu funkciju sa parametrom prevFields
-funkciji handleImageChange() dodajemo parametar e
-destruktuiramo varijablu const { files } iz metode e.target
-kreiramo varijablu const updatedImages 
-dodajemo petlji for()
-dodajemo funkciju setFields()
-u funkciju setFields() proslijedujemo anonimnu funkciju sa parametrom prevFields

38. Add Property POST API Route
-u komponenti PropertyAddForm.jsx form elementu dodajemo props action, method i encType
-u properties/route.js fajlu kreiramo i eksportujemo asinhronu funkciju POST() sa parametrom request
-u funkciji POST kreiramo blokove koda try - catch
-u blokove koda try - catch dodajemo funkciju new Response()
-u bloku koda try dodajemo metodu await request.formData()
-vrijednost metode request.formData() pohranjujemo u varijablu const formData
-kreiramo varijable const amenities i const images
-kreiramo varijablu objekt const propertyData

39. Get User & Submit To Database
-u api/properties/route.js fajl importujemo funkciju getServerSession iz paketa Next Auth
-importujemo funkciju authOptions
-u funkciju POST() dodajemo funkciju connectDB()
-kreiramo funkciju getServerSession(authOptions)
-vrijednost funkcije getServerSession() pohranjujemo u varijablu const session
-dodajemo uslov if (!session)
-u uslov if (!session) dodajemo funkciju new Response()
-kreiramo varijablu const userId
-u objekt const propertyData dodajemo varijablu owner: userId
-u folderu utils kreiramo getSessionUser.js fajl
-u getSessionUser.js fajlu kreiramo i eksportujemo asinhronu funkciju getSessionUser()
-u funkciju getSessionUser() dodajemo blokove koda try - catch
-u blok koda try dodajemo uslov if (!session || !session.user)
-u blok koda catch u return dodajemo return null
-u properties/route.js fajl importujemo i kreiramo funkciju getSessionUser()
-vrijednost funkcije getSessionUser() pohranjujemo u varijablu const sessionUser
-dodajemo uslov if (!sessionUser || !sessionUser.userId) 
-u uslov if dodajemo funkciju new Response()
-destruktuiramo varijablu const { userId } iz varijable sessionUser
-kreiramo varijablu const newProperty
-dodajemo metodu await newProperty.save()
-dodajemo return Response.redirect()

40. Cloudinary Image Upload
-otvorimo web stranicu https://cloudinary.com/ i kreiramo racun
-u .env.local fajlu kreiramo varijable CLOUDINARY_CLOUD_NAME, CLOUDINARY_API_KEY i CLOUDINARY_API_SECRET
-u terminalu instaliramo paket Cloudinary sa komandom npm i cloudinary
-na servisu Cloudinary kreiramo folder udemy-nextjs-propertypulse
-u folderu config kreiramo cloudinary.js fajl
-u cloudinary.js fajl importujemo varijablu cloudinary
-varijabli cloudinary dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo varijable cloud_name, api_key i api_secret
-varijablu cloudinary eksportujemo kao default
-u properties/route.js fajl importujemo varijablu cloudinary
-kreiramo varijablu const imageUploadPromises
-kreiramo petlju for (const image of images)
-u petlji for kreiramo varijable const imageBuffer, const imageArray, const imageData
-kreiramo varijablu const imageBase64
-kreiramo varijablu const result
-dodajemo metodu imageUploadPromises.push(result.secure_url)
-kreiramo varijablu const uploadedImages
-dodajemo metodu propertyData.images = uploadedImages
-posaljemo formu sa slikama i otvorimo folder sa slikama na servisu Cloudinary

41. Property Image Display
-u requests.js fajlu,u metodu fetch() dodajemo konfiguracioni objekt
-u next.config.js fajl dodajemo konfiguracioni objekt za prikazivanje slika sa servisa Cloudinary
-kreiramo komponentu PropertyImages.jsx
-u komponentu properties/[id]/page.jsx importujemo komandu PropertyImages.jsx
-u komponenti PropertyImages.jsx dodajemo funkciji PropertyImages() dodajemo parametar destruktuirani prop images
-u jsx-u u return izjavi dodajemo ternarni uslov images.length === 1 ? (...) : (...)
-dodajemo metodu images.map()
-div elementu u metodi map() dodajemo dinamicku klasu


Section 6: Profile & Manage Properties

42. User Profile Info Display
-u folderu app kreiramo folder profile i unutar njega komponentu page.jsx
-u komponentu profile/page.jsx importujemo komponente Image i Link
-u jsx-u, u return izjavi kreiramo HTML elemente za korisnika 
-importujemo i kreiramo funkciju useSession()
-importujemo sliku profileDefault
-destruktuiramo varijablu const { data: session } iz funkcije useSession()
-kreiramo tri varijable const profileImage, const profileName i const profileEmail

43. User Profile Listings
-u folderu api/properties kreiramo folder user
-u folderu user kreiramo folder [userId]
-u folderu [userId] kreiramo route.js fajl
-u [userId]/route.js fajlu kreiramo i eksportujemo asinhronu funkciju GET()
-u funkciji GET() kreiramo blokove koda try - catch
-funkciji GET dodajemo parametre request i objekt params
-u blok koda try dodajemo metodu await connectDB()
-kreiramo varijablu const userId
-dodajemo uslov if (!userId)
-kreiramo varijablu const properties
-dodajemo funkciju new Response()
-u blok koda catch dodajemo funkciju new Response()
-u pretrazivacu otvorimo rutu http://localhost:3000/api/properties/user/userId
-u komponentu profile/page.js importujemo funkcije useState i useEffect
-kreiramo state varijablu const properties i set funkciju setProperties
-kreiramo state varijablu const loading i set funkciju setLoading
-kreiramo funkciju useEffect()
-prvi argument funkcije useEffect() je anonimna funkcija u kojoj kreiramo asinhronu funkciju fetchUserProperties()
-drugi argument je niz u koji dodajemo varijablu session
-u funkciju fetchUserProperties() dodajemo uslov if (!userId) 
-dodajemo blokove koda try - catch - finally
-u bloku koda try kreiramo varijablu const res
-dodajemo uslov if (res.status === 200)
-u uslovu if (res.status === 200) kreiramo varijablu const data
-dodajemo funkciju setProperties(data)
-u blok koda finally dodajemo funkciju setLoading(false)
-u funkciju fetchUserProperties() dodajemo uslov if (session?.user?.id)
-u uslov if dodajemo pozivamo funkciju fetchUserProperties(session.user.id)
-u jsx-u u return izjavi dodajemo uslov !loading && properties.length === 0 && (...)
-dodajemo ternarni uslov loading ? (...) : (...)
-dodajemo metodu properties?.map()
-otvorimo rutu http://localhost:3000/profile
-dinamicki prikazujemo podatke u HTML elementima u metodi map()
-kreiramo asinhronu funkciju handleDeleteProperty() sa parametrom propertyId
-button elementu dodajemo dogadaj onClick
-u dogadaj onClick proslijedujemo anonimnu funkciju 
-u anonimnu funkciju proslijedujemo funkciju handleDeleteProperty

44. Deleting Properties
-u app/api/propertis/[id]/route.js fajl importujemo funkciju getSessionUser
-kreiramo i eksportujemo asinhronu funkciju DELETE()
-u funkciji DELETE() kreiramo blokove koda try - catch
-u bloku koda try kreiramo varijablu const propertyId
-kreiramo varijablu const sessionUser
-dodajemo uslov if (!sessionUser || !session.userId)
-u uslov if dodajemo funkciju new Response()
-destruktuiramo varijablu const { userId }
-kreiramo varijablu const property 
-dodajemo uslov  if (!property)
-dodajemo uslov if (property.owner.toString() !== userId)
-dodajemo metodu await property.deleteOne()
-dodajemo funkciju new Response()
-u komponenti profile/page.jsx, u funkciji handleDeleteProperty() kreiramo varijablu const confirmed
-dodajemo uslov if (!confirmed)
-kreiramo blokove koda try - catch
-u bloku koda try kreiramo varijablu const res
-dodajemo uslov if (res.status === 200)
-u uslovu if kreiramo varijablu const updatedProperties
-dodajemo funkciju setProperties(updatedProperties)
-dodajemo uslov else
-u uslov else dodajemo poruku alert()

// Delete image property flom Claudinary
export const DELETE = async (request, { params }) => {
  try {
    const propertyId = params.id;
 
    const sessionUser = await getSessionUser();
 
    // Check for session
    if (!sessionUser || !sessionUser.userId) {
      return new Response('User ID is required', { status: 401 });
    }
 
    const { userId } = sessionUser;
 
    await connectDB();
 
    const property = await Property.findById(propertyId);
 
    if (!property) return new Response('Property Not Found', { status: 404 });
 
    // Verify ownership
    if (property.owner.toString() !== userId) {
      return new Response('Unauthorized', { status: 401 });
    }
 
    // extract public id's from image url in DB
    const publicIds = property.images.map((imageUrl) => {
      const parts = imageUrl.split('/');
      return parts.at(-1).split('.').at(0);
    });
 
    // Delete images from Cloudinary
    if (publicIds.length > 0) {
      for (let publicId of publicIds) {
        await cloudinary.uploader.destroy('propertypulse/' + publicId);
      }
    }
 
    // Proceed with property deletion
    await property.deleteOne();
 
    return new Response('Property Deleted', {
      status: 200,
    });
  } catch (error) {
    console.log(error);
    return new Response('Something Went Wrong', { status: 500 });
  }
};


45. Toast Notifications
-u terminalu instaliramo paket React Toastify sa komandom npm i react-toastify
-u komponentu layout.jsx importujemo komponentu ToastContainer iz paketa React Toastify
-importujemo css stil za komponentu ToastContainer
-importujemo funkciju toast iz paketa React Toastify
-umjesto alert poruka dodajemo toast()

46. Edit Property Form
-u folderu app/properties/[id]/ kreiramo folder edit i komponentu page.jsx
-u folderu components kreiramo komponentu PropertyEditForm.jsx
-u komponentu edit/page.jsx importujemo komponentu PropertyEditForm.jsx
-u komponenti PropertyEditForm.jsx kreiramo funkciju handleSubmit
-form elementu dodajemo dogadaj onSubmit
-u dogadaj onSubmit proslijedujemo funkciju handleSubmit
-importujemo i kreiramo funkcije useParams() i useRouter() iz paketa Next Navigation
-importujemo funkciju toast
-importujemo funkciju fetchProperty
-kopiramo vecinu koda iz komponente PropertyAddForm.jsx 
-destruktuiramo varijablu const { id} iz funkcije useParams()
-vrijednost funkcije useRouter() pohranjujemo u varijablu const router
-kreiramo state varijablu loading i set funkciju setLoading
-u funkciji useEffect() kreiramo asinhronu funkciju fetchPropertyData()
-u funkciji fetchPropertyData() kreiramo blokove koda try - catch - finally
-u bloku koda try kreiramo varijablu const propertyData
-dodajemo funkciju setFields(propertyData)
-u finally blok koda dodajemo funkciju setLoading(false)
-u funkciji fetchPropertyData() dodajemo uslov if (propertyData && propertyData.rates)
-u uslovu if kreiramo varijablu const defaultRates
-kreiramo petlju for in
-u petlji for in dodajemo uslov if (defaultRates[rate])
-dodajemo metodu propertyData.rates = defaultRates

47. Update PUT API Route
-u folderu properties/[id]/route.js fajlu kreiramo i eksportujemo asinhronu funkciju PUT
-funkciji PUT dodajemo parametre request i { params }
-destruktuiramo varijablu const { id } = params
-kreiramo varijablu const existingProperty 
-dodajemo uslov if (!existingProperty)
-u uslov if dodajemo funkciju new Response()
-dodajemo uslov if (existingProperty.owner.toString() !== userId)
-u uslov if dodajemo funkciju new Response()
-kreiramo varijablu const propertyData 
-dodajemo metodu await Property.findByIdAndUpdate(id, propertyData)
-vrijednost metode Property.findByIdAndUpdate() pohranjujemo u varijablu const updatedProperty
-dodajemo metodu new Response(JSON.stringify(updatedProperty), { ... })
-u komponenti PropertyEditForm.jsx, funkciji handleSubmit() dodajemo parametar e
-u funkciju handleSubmit() dodajemo metodu e.preventDefault()
-kreiramo blokove koda try - catch
-u bloku koda try kreiramo varijablu const res
-kreiramo varijablu const formData
-dodajemo uslov if (res.status === 200)
-u uslov if (res.status === 200) dodajemo metodu router.push()
-dodajemo uslov else if (res.status === 401 || res.status === 403)
-u uslov if dodajemo funkciju toast.error()
-dodajemo uslov else
-u uslov else dodajemo funkciju toast.error()
-u blok koda catch dodajemo funkciju toast.error()


Section 7: Map, Bookmarks & Sharing

48. Geocoding & Mapbox Map
-otvorimo web stranicu https://mapbox.com/ i kreiramo racun
-u fajlovima .env.local i .env.local.example kreiramo varijable NEXT_PUBLIC_MAPBOX_TOKEN, NEXT_PUBLIC_GOOGLE_GEOCODING_API_KEY
-u terminalu instaliramo pakete sa komandom npm i react-map-gl mapbox-gl react-geocode
-u folderu components kreiramo komponentu PropertyMap.jsx
-u komponenti PropertyMap.jsx, funkciji PropertyMap() dodajemo parametar destruktuirani prop property
-kreiramo state varijable const lat, lng, viewport i loading
-kreiramo set funkcije setLap, setLng, setViewport i setLoading
-importujemo i kreiramo funkciju setDefaults()
-u funkciju setDefaults() dodajemo konfiguracioni objekt
-kreiramo funkciju useEffect()
-prvi argument funkcije useEffect() je anonimna funkcija a drugi argument prazan niz
-u anonimnoj funkciji kreiramo asinhronu funkciju fetchCoords()
-u funkciji fetchCoords() kreiramo varijablu const res
-destruktuiramo varijable const { lat, lng }
-pozivamo funkciju fetchCoords()
-u funkciju fetchCoords() dodajemo funkcije setLat(lat), setLng(lng), setViewport({ ... }), setLoading(false)
-dodajemo uslov if (loading)
-u jsx, u return izjavu dodajemo komponentu Map
-komponenti Map dodajemo vise props
-u kopiramo Map dodajemo komponentu Marker

49. Handle Geocode Error
-u komponenti PropertyMap.jsx kreiramo state varijablu const geocodeError
-kreiramo set funkciju setGeocodeError
-u funkciju fetchCoords dodajemo blokove koda try - catch
-u blok koda try dodajemo uslov if (res.results.length === 0)
-u blok koda catch dodajemo funkcije setGeocodeError(true) i setLoading(false);
-dodajemo uslov if (geocodeError)

50. Property Page Cleanup
-u folderu components kreiramo komponentu BookmarkButton.jsx
-u komponentu properties/[id]/page.jsx importujemo komponentu BookmarkButton.jsx
-u jsx-u, u return izjavi komponenti BookmarkButton dodajemo prop property
-u prop property proslijedujemo vrijednost varijable property
-kreiramo komponentu ShareButtons.jsx
-u komponentu properties/[id]/page.jsx importujemo komponentu ShareButtons.jsx
-kreiramo komponentu PropertyContactForm.jsx
-u komponentu properties/[id]/page.js importujemo komponentu PropertyContactForm.jsx

51. Bookmark API Route
-u folderu app/api kreiramo folder bookmarks i route.js fajl
-u route.js fajlu kreiramo i eksportujemo funkciju POST
-u funkciji POST kreiramo blokove koda try - catch
-u blok koda try dodajemo funkciju await connectDB()
-iz metode await request.json() destruktuiramo varijablu const { propertyId }
-vrijednost metode await getSessionUser() pohranjujemo u varijablu const sessionUser
-dodajemo uslov if (!sessionUser || !session.userId)
-destruktuiramo varijablu const { userId }
-kreiramo varijablu const user 
-kreiramo varijable let isBookmarked i let message
-dodajemo uslov  if (isBookmarked) - else
-dodajemo return new Response()

52. Bookmark Button Request
-u komponentu BookmarkButton.jsx importujemo i kreiramo funkciju useSession()
-funkciji BookmarkButton() dodajemo parametar destruktuirani prop property
-destruktuiramo varijablu const { data: session }
-kreiramo varijablu const userId
-kreiramo state varijablu isBookmarked i set funkciju setIsBookmarked
-kreiramo funkciju handleClick()
-button elementu dodajemo dogadaj onClick i proslijedujemo funkciju handleClick
-u funkciju handleClick() dodajemo uslov  if (!userId)
-dodajemo blokove koda try - catch
-u bloku koda try kreiramo varijablu const res
-dodajemo uslov if (res.status === 200)
-u uslovu if (res.status === 200) kreiramo varijablu const data
-dodajemo objekt toast.success()
-dodajemo funkciju setIsBookmarked(data.isBookmarked)

53. Bookmark Status & Button Toggle
-u komponenti BookmarkButton.jsx u jsx-u, return izjavi dodajemo ternarni uslov isBookmarked ? (...) : (...) za pojavljivanje dugmadi
-u folderu app/api/bookmarks kreiramo folder check i route.js fajl
-u check/route.js fajlu kreiramo i eksportujemo funkciju POST()
-u komponenti BookmarkButton.jsx kreiramo funkcija useEffect()
-u funkciji useEffect kreiramo asinhronu funkciju checkBookmarkStatus() 
-kreiramo state varijablu const loading i set funkciju setLoading()
-dodajemo uslov if (loading)
-u funkciju useEffect() dodajemo uslov if (!userId) 

54. Saved properties Page
-u folderu app/properties kreiramo folder saved i komponentu page.jsx
-u check/route.js fajlu kreiramo i eksportujemo asinhronu funkciju GET()
-u komponenti saved/page.jsx kreiramo state varijable const properties i const loading,  
-kreiramo set funkcije setProperties() i setLoading()
-importujemo i kreiramo funkciju useEffect()
-u funkciji useEffect() kreiramo asinhronu funkciju fetchSavedProperties()
-u funkciji fetchSavedProperties() kreiramo blokove koda try - catch - finally

55. Share Buttons
-otvorimo link: https://www.npmjs.com/package/react-share
-u terminalu instaliramo paket React Share sa komandom npm i react-share
-u komponentu ShareButtons.jsx importujemo komponente Button i ikonice
-komponentama Button dodajemo props


Section 8: Property Search

56. Property Search Component
-u folderu components kreiramo komponentu PropertySearchForm.jsx
-u komponentu Hero.jsx importujemo komponentu PropertySearchForm.jsx
-u komponentu PropertySearchForm.jsx dodajemo direktivu 'use client'
-kreiramo state varijable const location i const propertyType
-kreiramo set funkcije setLocation i setPropertyType
-u input element dodajemo prop value i dogadaj onChange
-u prop value proslijedujemo vrijednost varijable location
-u dogadaj onChange proslijedujemo anonimnu funkciju sa parametrom e
-u anonimnu funkciju proslijedujemo funkciju setLocation()
-isto ponovimo za select element
-kreiramo funkciju handleSubmit()
-form elementu dodajemo dogadaj onSubmit
-u dogadaj onSubmit proslijedujemo funkciju handleSubmit
-importujemo i kreiramo funkciju useRouter()
-vrijednost funkcije user() pohranjujemo u varijablu const router
-dodajemo uslov if (location === '' && propertyType === 'All') i else
-u uslov if dodajemo metodu router.push('/properties')
-u uslovu else kreiramo varijablu const query
-dodajemo metodu router.push()

57. Search API Endpoint
-u folderu app/api/properties kreiramo folder search i route.js fajl
-u search/route.js fajlu kreiramo i eksportujemo asinhronu funkciju GET() sa parametrom request
-u funkciji GET() kreiramo blokove koda try - catch
-u blok koda try dodajemo funkciju await connectDB()
-destruktuiramo varijablu const { searchParams } iz funkcije new URL(request.url)
-kreiramo varijablu const location i const propertyType
-dodajemo metodu new Response()
-u blok koda catch dodajemo metodu new Response()
-kreiramo varijablu const locationPattern
-kreiramo varijablu objekt let query 
-dodajemo uslov if (propertyType && propertyType !== 'All')
-kreiramo varijablu const properties
-u metodu JSON.stringify() proslijedujemo varijablu properties
-otvorimo rutu http://localhost:3000/api/properties/search?location=Boston&propertyType=All
-otvorimo rutu http://localhost:3000/properties/search-results?location=Boston&propertyType=All

58. Fetch Results From API
-u folderu app/properties kreiramo folder search-results i komponentu page.jsx
-u komponenti page.jsx kreiramo funkciju SearchResultsPage()
-kreiramo i importujemo funkciju useSearchParams() iz paketa Next/Navigation
-vrijednost funkcije useSearchParams() pohranjujemo u varijablu const searchParams
-kreiramo state varijable const properties i const loading
-kreiramo set funkcije setProperties i setLoading
-kreiramo varijable const location i const propertyType
-kreiramo funkciju useEffect()
-prvi argument je anonimna funkcija u kojoj kreiramo asinhronu funkciju fetchSearchResults
-drugi argument je niz u koji dodajemo varijable location, propertyType
-u funkciji fetchSearchResults() kreiramo blokove koda try - catch - finally
-u bloku koda try kreiramo varijablu const res
-dodajemo uslov if (res.status === 200) i else
-u uslovu if (res.status === 200) kreiramo varijablu const data
-dodajemo funkciju setProperties(data)
-u uslov else dodajemo funkciju setProperties([])
-u blok koda finally dodajemo funkciju setLoading(false)

59. Display Search Results
-u komponenti search-results/page.jsx, u jsx-u u return izjavi dodajemo ternarni uslov loading ? (...) : (...)
-dodajemo metodu properties?.map()
-u metodu map() dodajemo komponentu PropertyCard
-importujemo komponentu PropertySearchForm.jsx
-u komponentu properties/page.jsx importujemo komponentu PropertySearchForm.jsx


Section 9: Messaging System

60. Message Model & Form State
-u folderu models kreiramo Message.js fajl
-u Message.js fajlu kreiramo varijable const MessageSchema i const Message
-u komponenti PropertyContactForm.jsx, funkciji PropertyContactForm() dodajemo parametar destruktuirani prop property
-kreiramo state varijable i set funkcije
-input elementima dodajemo prop value i dogadaj onChange
-kreiramo funkciju handleSubmit()
-form elementu dodajemo dogadaj onSubmit
-u dogadaj onSubmit proslijedujemo funkciju handleSubmit
-u funkciji handleSubmit() kreiramo objekt varijablu const data
-dodajemo ternarni uslov wasSubmitted ? (...) : (...)

61. Message Submit & API Route
-u folderu app/api kreiramo folder messages i route.js fajl
-u route.js fajlu kreiramo i eksportujemo funkciju POST()
-u funkciji POST() kreiramo blokove koda try - catch
-u blok koda try dodajemo metodu await connectDB()
-dodajemo metodu request.json()
-iz metode request.json() destruktuiramo varijable const { name, email, phone, message, property, ricipient }
-kreiramo varijablu const sessionUser
-dodajemo uslov if (!sessionUser || !sessionUser.user)
-u uslov if dodajemo return new Response()
-destruktuiramo varijablu const { user }
-dodajemo uslov if (user.id === recipient) kojim sprijecavamo da posaljemo poruku samom sebi
-kreiramo varijablu const newMessage 
-dodajemo metodu await newMessage.save()
-u blok koda catch dodajemo return new Response()
-u komponentu PropertyContactForm.jsx, u funkciju handleSubmit() dodajemo blokove koda try - catch - finally
-u bloku koda try kreiramo varijablu const res
-dodajemo uslov if (res.status === 200)
-u uslov if (res.status === 200) dodajemo funkciju toast.success() i funkciju setWasSubmitted(true)
-dodajemo uslov else if (res.status === 400 || res.status ===  401)
-u uslov else if dodajemo funkciju toast.error(data.message)
-dodajemo uslov else i funkciju toast.error('Error sending form!')
-u blok koda catch dodajemo funkciju toast.error('Error sending form!')
-u blok koda finally dodajemo ser funkcije

62. Require Auth For Contact Form
-u komponenti PropertyContactForm.jsx. u uslovu res.status === 400 || res.status ===  401
-importujemo i kreiramo funkciju useSession()
-destruktuiramo varijablu const { data: session } iz funkcije useSession()
-u jsx-u, u return izjavi dodajemo ternarni uslov !session ? (...) : (...)

63. Fetch Messages
-u folderu app kreiramo folder messages i komponentu page.jsx
-u komponenti page.jsx kreiramo funkciju MessagesPage()
-u folderu app/api/messages kreiramo route.js fajl
-u route.js fajlu kreiramo i eksportujemo asinhronu funkciju GET()
-u funkcija GET() kreiramo blokove koda try - catch
-u blok koda try dodajemo metodu await connectDB()
-kreiramo varijablu const sessionUser
-dodajemo uslov if (!sessionUser || !sessionUser.user)
-destruktuiramo varijablu const { userId }
-kreiramo varijablu const messages
-dodajemo return new Response(JSON.stringify(messages))
-u blok koda catch dodajemo return new Response()
-u folderu components kreiramo komponentu Messages.jsx
-u komponentu Messages.jsx importujemo direktivu 'use client'
-kreiramo state varijable const messages i const loading
-kreiramo set funkcije setMessages i setLoading
-kreiramo funkciju useEffect()
-prvi argument funkcije useEffect() je anonimna funkcija, a drugi argument prazan niz []
-u anonimnoj funkciji kreiramo asinhronu funkciju getMessages()
-u funkciji getMessages() kreiramo blokove koda try - catch - finally
-u bloku koda try kreiramo varijablu const res
-dodajemo uslov if (res.status === 200)
-u uslovu if kreiramo varijablu const data i dodajemo funkciju setMessages(data)
-u bloku koda catch (error) ispisujemo error u konzoli
-u bloku koda finally dodajemo setLoading(false)
-u komponentu app/messages/pages.jsx importujemo komponentu Messages.jsx

64. Display Messages
-u folderu components kreiramo komponentu Message.jsx
-u komponentu Messages.jsx importujemo komponentu Message.jsx
-dodajemo ternarni uslov messages.length === 0 ? (...) : (...)
-dodajemo metodu messages.map()
-u metodu map dodajemo komponentu Message
-komponenti Message dodajemo prop key i message
-dodajemo ternarni uslov loading ? (<Spinner loading={loading}/>) : (...)
-u komponenti Message.jsx, funkciji Message dodajemo parametar destruktuirani prop message
-dinamicki prikazujemo vrijednost varijabla u jsx-u

65. Mark As Read
-u folderu app/api/messages kreiramo folder [id] i route.js fajl
-u [id]/route.js fajlu kreiramo i eksportujemo asinhronu funkciju PUT()
-funkciji PUT() dodajemo parametre request i { params }
-u funkciji PUT() kreiramo blokove koda try - catch
-u blok koda try dodajemo metodu await connectDB()
-destruktuiramo varijablu const { id }
-kreiramo varijablu const sessionUser
-dodajemo uslov if (!sessionUser || !sessionUser.user)
-destruktuiramo varijablu const { userId }
-kreiramo varijablu const message
-dodajemo uslov if (!message)
-dodajemo uslov if (message.recipient.toString() !== userId) 
-dodajemo metodu message.read = !message.read
-dodajemo metodu await message.save()
-dodajemo metodu return new Response(JSON.stringify(message))
-u blok koda catch dodajemo return new Response('Something went wrong')
-u komponentu Message.jsx dodajemo direktivu 'use client'
-kreiramo state varijablu const isRead i set funkciju setIsRead
-u jsx dodajemo uslov !isRead && (...)
-kreiramo asinhronu funkciju handleReadClick
-button elementu Mark As Read (oznaci kao procitano) dodajemo dogadaj onClick
-u dogadaj onClick proslijedujemo funkciju handleReadClick
-u button element dodajemo uslov {isRead ? 'Mark As New' : 'Mark As Read'}
-u funkciji handleReadClick() kreiramo blokove koda try - catch
-u bloku koda try kreiramo varijablu const res
-dodajemo uslov if (res.status === 200)
-u uslovu if (res.status === 200) destruktuiramo varijablu const { read }
-dodajemo funkciju setIsRead(read)
-dodajemo uslove if (read) i else
-u uslove if (read) i else dodajemo funkcije toast.success()
-u blok koda catch(error) dodajemo funkciju toast.error()

66. Delete Messages
-u messages/[id]/route.js fajlu kreiramo asinhronu funkciju DELETE()
-funkciji DELETE() dodajemo parametre request i { params }
-kreiramo blokove koda try - catch
-u blok koda try dodajemo metodu await connectDB()
-destruktuiramo varijablu const { id }
-kreiramo varijablu const sessionUser 
-dodajemo uslov if (!sessionUser || !sessionUser.user)
-destruktuiramo varijablu const { userId }
-kreiramo varijablu const message
-dodajemo uslov if (!message)
-dodajemo uslov if (message.recipient.toString() !== userId)
-dodajemo metodu await message.deleteOne()
-dodajemo metodu return new Response()
-u blok koda catch dodajemo return new Response()
-u komponenti Message.jsx kreiramo asinhronu funkciju handleDeleteClick()
-u funkciji handleDeleteClick() kreiramo blokove koda try - catch
-u bloku koda try kreiramo varijablu const res
-dodajemo uslov if (res.status === 200)
-u uslov if dodajemo funkciju toast.success()
-u blok koda catch dodajemo funkciju toast.error()
-kreiramo state varijablu const isDeleted i set funkciju const setIsDeleted
-u uslov if (res.status === 200) dodajemo funkciju setIsDeleted(true)
-dodajemo uslov return (isDeleted)

67. Order New First
-u app/api/messages/route.js fajlu kreiramo varijable const readMessages i const unreadMessages
-kreiramo varijablu const messages

68. New Message Count Display
-u folderu app/api/messages kreiramo folderu unread-count i route.js fajl
-u unread-count/route.js fajlu kreiramo i eksportujemo asinhronu funkciju GET() 
-u funkciji GET kreiramo blokove koda try - catch
-u blok koda try dodajemo metodu await connectDB()
-kreiramo varijablu const sessionUser
-dodajemo uslov if (!sessionUser || !sessionUser.user)
-destruktuiramo varijablu const { userId }
-dodajemo metodu await Message.countDocuments({ ... })
-vrijednost metode await Message.countDocuments({ ... }) pohranjujemo u varijablu const count
-dodajemo metodu return new Response()
-u blok koda catch dodajemo metodu return new Response()
-u folderu components kreiramo komponentu UnreadMessageCount.jsx
-u komponentu Navbar.jsx importujemo komponentu UnreadMessageCount.jsx
-u komponenti UnreadMessageCount.jsx kreiramo state varijablu const unreadCount
-kreiramo set funkciju setUnreadCount
-u komponenti Navbar.jsx, u jsx-u komponenti UnreadMessageCount dodajemo prop session
-u prop session proslijedujemo vrijednost varijable session
-u komponenti UnreadMessageCount.jsx, funkciji UnreadMessageCount() dodajemo parametar destruktuirani prop session
-dodajemo varijablu unreadCount u jsx, u return izjavu
-importujemo i kreiramo funkciju useEffect()
-prvi argument funkcije useEffect() je anonimna funkcija, a drugi argument je niz 
-u anonimnoj funkciji kreiramo asinhronu funkciju fetchUnreadMessages()
-u funkciji fetchUnreadMessages() kreiramo blokove koda try - catch
-u bloku koda try kreiramo varijablu const res
-dodajemo uslov if (res.status === 200)
-u uslovu if (res.status === 200) kreiramo varijablu const data
-dodajemo funkciju setUnreadCount(data)
-u jsx, u return izjavu dodajemo uslov return unreadCount > 0 && (...)

69. Global Context For Unread Messages
-kreiramo folder context i globalContext.js fajl
-u globalContext.js fajl importujemo funkcije createContext, useContext, useState
-kreiramo varijablu const GlobalContext
-kreiramo i eksportujemo funkciju GlobalProvider() sa parametrom destruktuiranim prop children
-u return izjavu dodajemo komponentu GlobalContext.Provider sa otvorenim i zatvorenim tagom
-izmedu tagova dodajemo prop children
-kreiramo i eksportujemo funkciju useGlobalContext()
-iz komponente UnreadMessageCount.jsx premjestamo state varijablu const unreadCount i set funkciju setUnreadCount
-komponenti GlobalContext.Provider dodajemo prop value
-u prop value proslijedujemo varijabla unreadCount i funkciju setUnreadCount
-u komponentu layout.jsx importujemo komponentu GlobalProvider
-u jsx, u return izjavu dodajemo komponentu GlobalProvider sa otvorenim i zatvorenim tagom
-u komponentu UnreadMessageCount.jsx importujemo i kreiramo funkciju useGlobalContext()
-destruktuiramo varijabla unreadCount i funkciju setUnreadCount iz funkcije useGlobalContext()
-u komponentu Message.jsx importujemo i kreiramo funkciju useGlobalContext()
-destruktuiramo varijablu const { setUnreadCount } iz funkcije useGlobalContext()
-u funkciju handleReadClick(), u uslov if (res.status === 200) dodajemo funkciju setUnreadCount()
-u funkciju handleDeleteClick(), u uslov if (res.status === 200) dodajemo funkciju setUnreadCount()


Section 10: Pagination, Featured, Lightbox & Deploy

70. Properties Client Component Refactor
-u folderu components kreiramo komponentu Properties.jsx
-u komponenti Properties.jsx kreiramo state varijable const properties i const loading
-kreiramo state funkcije setProperties i setLoading
-u jsx, u return izjavu dodajemo ternarni operator loading ? : (...) : (...)
-u komponentu app/properties/page.jsx importujemo komponentu Properties.jsx
-importujemo i kreiramo funkciju useEffect()
-prvi argument je anonimna funkcija, a drugi argument niz []
-u anonimnoj funkciji kreiramo asinhronu funkciju fetchProperties()
-u funkciju fetchProperties() dodajemo blokove koda try - catch - finally
-u bloku koda try kreiramo varijablu const res
-dodajemo uslov if (!res.ok)
-kreiramo varijablu const data
-dodajemo funkciju setProperties(data)
-u bloku koda catch ispisujemo error poruku
-u blok koda finally dodajemo funkciju setLoading(false)

71. Implement Pagination
-u app/api/properties/route.js fajlu, u funkciji GET() kreiramo varijable const page i const pageSize
-kreiramo varijable const skip i const total
-kreiramo varijablu objekt const result 
-u funkciju new Response() proslijedujemo varijablu result
-u komponenti HomeProperties preimenujemo varijablu const properties u const data 
-u komponenti Properties.jsx kreiramo state varijable const page, const pageSize, const totalItems
-kreiramo set funkcije setPage, setPageSize, setTotalItems
-u funkciju fetchProperties(), u blok koda try dodajemo funkciju setTotalItems

72. Pagination Component
-u folderu components kreiramo komponentu Pagination.jsx
-u komponentu Properties.jsx importujemo komponentu Pagination.jsx
-u jsx-u, u return izjavi komponenti Pagination dodajemo vise props
-kreiramo funkciju handlePageChange() sa parametrom newPage
-u funkciju handlePageChange() dodajemo funkciju setPage(newPage)
-u komponenti Pagination.jsx, funkciji Pagination() dodajemo parametre destruktuirane props { page, pageSize, totalItems, onPageChange }
-kreiramo varijablu const totalPages
-button elementima dodajemo prop disabled
-button elementima dodajemo dogadaje onClick
-kreiramo funkciju handlePageChange() sa parametrom newPage
-u dogadaje onClick proslijedujemo vrijednost funkcija handlePageChange()
-u funkciju handlePageChange() dodajemo uslov if (newPage >= 1 && newPage <= totalPages) 
-u uslov if dodajemo funkciju onPageChange(newPage)

73. Photoswipe Lightbox
-otvorimo link https://www.npmjs.com/package/photoswipe
-u terminalu instaliramo paket Photoswipe sa komandom npm i photoswipe
-otvorimo link https://www.npmjs.com/package/react-photoswipe-gallery
-u terminalu instaliramo paket React Photoswipe Gallery sa komandom 
-u komponentu layout.jsx importujemo css stil za Photoswipe
-u komponentu PropertyImages.jsx importujemo komponente Gallery i Item iz paketa React Photoswipe Gallery
-u jsx, u return izjavu dodajemo komponentu Gallery sa otvorenim i zatvorenim tagom
-u ternarni uslov images.length === 1 dodajemo komponentu Item
-komponenti Item dodajemo props iz dokumentacije
-u komponentu Item dodajemo anonimnu funkciju sa parametrom objekt ref i open
-u anonimnu funkciju dodajemo komponentu Image
-komponenti Image dodajemo prop ref i dogadaj onClick
-u metodu map() dodajemo komponentu Item

74. Fetch Featured Properties
-u MongoDB bazi odredenim nekretnimama stavimo opciju isFeatured: true
-u folderu app/api/properties kreiramo folder featured i route.js fajl
-u featured/route.js fajlu kreiramo i eksportujemo funkciju GET() sa parametrom request
-importujemo funkcije connectDB i model Property
-u funkciji GET() kreiramo blokove koda try - catch
-u blok koda try dodajemo metodu await connectDB()
-kreiramo varijablu const properties
-dodajemo funkciju return new Response()
-u blok koda catch ispisujemo error u konzoli
-dodajemo return new Response()
-u folderu components kreiramo komponentu FeaturedProperties.jsx
-u komponentu app/page.jsx importujemo komponentu FeaturedProperties.jsx
-u utils/request.js fajlu funkciji fetchProperties() dodajemo parametar
-u metodi fetch() dodajemo ternarni uslov showFeatured ? '/featured' : ''
-u komponentu FeaturedProperties.jsx importujemo i kreiramo funkciju fetchProperties()
-vrijednost funkcije fetchProperties() pohranjujemo u varijablu const properties

75. Featured Property Component
-u folderu components kreiramo komponentu FeaturedPropertyCard.jsx
-u komponentu FeaturedProperties.jsx importujemo komponentu FeaturedPropertyCard.jsx
-dodajemo uslov properties.length > 0 && (...)
-u jsx, u return izjavi dodajemo metodu properties?.map()
-u komponenti FeaturedPropertyCard.jsx, funkciji FeaturedPropertyCard() dodajemo parametar destruktuirani prop property
-u jsx-u, u return izjavi dinamicki prikazujemo vrijednost varijabli
-kreiramo funkciju getRateDisplay()
-importujemo React ikonice

76. Deploy To Vercel
-otvorimo link https://www.npmjs.com/package/mongodb
-u terminalu instaliramo MongoDB paket npm install mongodb
-kreiramo bazu podataka na web stranici https://www.mongodb.com/atlas/database
-deplojamo projekt na web stranicu https://vercel.com/
-dodamo env varijable
